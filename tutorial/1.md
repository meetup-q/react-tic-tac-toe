- [Project Initialized](#project-initialized)
- [第一次試運行](#第一次試運行)
- [starter-code 解釋](#starter-code-解釋)
  - [component and JSX](#component-and-jsx)
- [ATOM to Component](#atom-to-component)
- [state and props](#state-and-props)
  - [props in](#props-in)
  - [set state](#set-state)
  - [one way data flow](#one-way-data-flow)

# Project Initialized

create-react-app 之後我們的 react project folder 就會出現預設的 react 頁面。接著把不必要的檔案刪除，我的 src/ 裡面只會留下 App.js, index.js, App.test.js, reportWebVitals.js, setupTests.js。

首先讓我們介紹一下 App.js 這個 component，若我們沿用 default 的 file structure 它會是所有 component 的 root，也就是最上層的 component。

接著我們將官方提供的 starter code 放上。請各位學員複製下方的 code block。


``` jsx
// App.js
import React from 'react';
import Board from './Board';

class App extends React.Component {
  render() {
    return (
      <div className="game">
        <div className="game-board">
          <Board />
        </div>
        <div className="game-info">
          <div>{/* stat>
          <ol>{/* TODO */}</ol>
        </div>
      </div>
    );
  }
}

export default App;
```
``` jsx
// Board.js
import React from 'react';

class Board extends React.Component {
  renderSquare(i) {
    return <Square />;
  }
  render() {
    const status = "Next player: X";

    return (
      <div>
        <div className="status">{status}</div>
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}

export default Board
```
```jsx
// Square.js
import React from 'react';

class Square extends React.Component {
  render() {
    return <button className="square">{/* TODO */}</button>;
  }
}
export default Square
```

# 第一次試運行
馬上來試試看到目前為止一切是否正常
在 command line 進入當前資料夾，並且輸入 npm start

運行成功，但我們發現畫面跟官方的不一樣，原來是沒有引用 css。

注意，react.js 的功能是協助開發者更快的開發前端的操作跟渲染邏輯，UI/UX 仍有賴於美術設計與 css 的協助，而如 bootstrap、tailwind 等 css 框架可以使用 react 相容版。

在 react 中，引用 css 方法很簡單，可以直接把 css 檔案當作 component import 到 react 中。我們將官方提供的 css 儲存到 `tic-tac-tow.css` 中並引用進 `App.js`。

```jsx
import './tic-tac-toe.css'
```

儲存所有變更之後，再回頭看看成果，已經出現跟官方一樣的畫面了！

# starter-code 解釋

首先，我們有三個 components，每一個 component 裡面都有 function render() 會 return 出一個像字串又像 html tags 但裡面又夾雜著 js code 的東西，這個怪異的東西叫做 JSX，它是一個語法 bable 會先將它編譯成複雜的 react.CreateElement，雖然說 JSX 並不是 react.js 的必要配件，但不使用很難維護更複雜的 html 結構。

JSX 不是字串，不需要 quaotation mark 包覆，他也不是 html tags，有些語法不一樣，例如 class 要寫作 className，它可以融入 javascript 來寫邏輯控制。

[babel repl](https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.6&spec=false&loose=false&code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bz5waHgdMIAmaRxOXEz2Tl5-BP8wQKksUztpQhgAbx4YGDzYVVU05NSAahgAZg6amH8oeTowUx4e2uxGUQA3Qh6ASDwiLq7solGcCenKxoBfdg2Z2rG2fZ67Hm2gA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=react&prettier=true&targets=&version=7.16.12&externalPlugins=&assumptions=%7B%7D)

若你已經寫 jQuery 好長一段時間了，你就會知道眼前的這段程式碼有多美妙。且讓我解釋一下

寫 jQuery 的時候我們必須先在 html file 裡面寫好 UI，再到 JS file 裡面撰寫 DOM 的操作邏輯。這樣做的缺點是 UI 與 logic 端分離了，當我看著一段 html tags 思考著他的 DOM 該怎麼變動時，需要切換到另一個 editor 去撰寫邏輯，development experiment 會變得很差；又所有 UI 都得寫在一起，會讓 html 長得好幾層樓高，tag 忘記 close 都有可能，而且要搜尋哪個 id 的時候需要深潛到一大堆無邏輯可言的 html 裡面尋找，很是不便。

react 就很好地解決了 jquery 遇到的困難，因為它使用了 JSX 。JSX 是一個 mind blowing 的工具，第一次看到它時很讓我驚訝，它把 html 跟 javascript 結合在一塊，讓前端的 UI 跟 logic 兩端結合在一起，當我們看著這段 html tags 的時候就可以馬上知道他會是什麼長相還有什麼功能！

為什麼 Babel 甘願為 JSX 寫 compile 邏輯？因為 Facebook 給他錢，讓他叫乾爹乾媽。

## component and JSX
我們先來看看 component Board 裡面， function renderSquare 回傳的是 <Square />，它就是另一個 component Square。我們可以發現在 JSX 裡面我們可以把定義好的 component 以類似 html tag 的寫法擺進另一個 component 裡面。mind-blowing!

further more，component 也可以寫成下面這個 code block 的樣子，用成對的 tag 將一段 element 包起來，傳到 `Square` 裡面，使這段 element 變成 component `Square` 的 children elements。我們也可以在 tag 中增加 property 當作參數傳進 `Square` 裡，但這一部分會再等一下的 state and props 中解釋，總之就是要讓你知道 JSX 有多麽令人驚艷。

```jsx
<Square className="col-12" property1=true property2=false property3=100 >
  <div>
    This is a child.
  </div>
</Square>
```

# ATOM to Component
我們現在有三個 components，分別是 App, Board, Square，藉由觀察它們的 JSX，就會發現之中的階層關係是 App -> Board -> Square，我們現在來 breakdown 他們的關係。

一般來說，我們會從最頂層的 dom 逐步實作出我們的，因為我們都不是 God of frontend，不知道到最後我們需要怎麼 structure code。

首先我們構思出一個 layout，在這個 layout 上我們要放一個九宮格，下面放狀態列等等。所以我們的 App 的 layout 才會長那樣，搭配一些 class 準備用 css 調整出我們要的 style。

接著我們思考一下九宮格需要什麼樣的功能
UI 面：
1. 它要有九個格子
2. 九宮格得是 3*3 的陣列方格
3. 每個格子都能放進一個圈圈或叉叉
Logic 面：
1. 每個格子要能獨立作業，保存圈圈叉叉的狀態
2. 為了判定勝負我們需要一個統籌所有結果的地方

從上面我們的結論我們可以想到 tic-tac-toe 的九宮格需要很多功能，所以我們必須把它分出來做一個 component，就是 `Board`，而如果你夠細心地思考就會發現，每個格子的功能也不簡單，那也該獨立成一個 component，就是 `Square`。

![atom to component to page](https://blog.logicwind.com/content/images/2020/06/atomic-design-2-1-1024x359.png)

上面的思考過程可以了解到，我們可以將一個複雜的功能拆解開來，利用以最小的單位去慢慢地組成。divide and conqur
react 的思考邏輯如上圖，以 atoms 組成 component 再組成一個 page 最後完成一個 app。atoms 指的是像一個按鈕、一個 input 等等，小且瑣碎的單體；component 指的是像一個 card、一個表單或是一個 jumbotron，component 指的是具有完整功能單體，但不足以成為一個頁面；利用多個 component 建構起來的畫面就是一個 page；而多個 pages 串連起來的全功能組織就是一個 app。從我們剛剛介紹過的種種功能已經能感受到，react.js 的設計可以把上面的想法完整實作。

# state and props
## props in

我們繼續跟著官方的教學文件繼續實作 tic-tac-toe，我們要在九宮格上寫字。

在 `Board` 中，starter-code 已經定義好一個 function `renderSquare` ，那是為了現在將 property `value` 傳進 `Square` 裡所設計的，所以我們把這個函數做點修改。如下
```jsx
renderSquare(i){
  return <Square value={i}>
}
```
如此，我們就能把 value 這個參數傳進 `Square` 裡了，接著修改 `Square` 裡的`render()`來把參數引入。
```jsx
render() {
  return <button className="square">
    {this.props.value}
  </button>;
}
```
我們增加了 `{this.props.value}`，這邊稍做解釋。所有在外傳進 component 的參數都會放近 new instance 的 `props` 中，我們傳入的參數又存在變數 `value`，所以要調用 `props` 中的 `value`,而因為是每一個 instance 的 `props`，所以要用 `this` 來調用之。在 javascript 裡，一個物件的實例 instance 要調用自身的 attribute or method，就要使用 this。

在 starter-code 裡，我們傳進 `Square` 的數字是 012/345/678,我們期待在 compile 出來的畫面也會如此，以證明目前的進展一切正常。

## set state

props refers to property, 表示這是不可以變動的。而 state 則是狀態，觀其名可知這是可以變動的。
而 state 只存在於一個 component 中，換言之 component 只能改變自己的 state。

ES6 的 class 的規定實例的 attribute 必須在 `constructor` 中宣告，所以我們要在 `constructor()` 中宣告 state，如下。其中的 `props` 與 `super(props)` 的寫法是規定，這樣才能將 `props` 送進物件的屬性中。

>In JavaScript classes, you need to always call super when defining the constructor of a subclass. All React component classes that have a constructor should start with a super(props) call.

```jsx
constructor(props) {
  super(props);
  this.state = {
    value: null,
  };
}
```
解釋這段 code。我們先宣告 state 這個屬性，而這個屬性是一個 object，注意，屬性的變數名稱一定要使用 state，不然不能用對應的函數改變 `state`。

宣告完 state 之後，我們就可以來思考要在哪裡改變 state 了，我們要做圈圈叉叉遊戲，我們希望九宮格地格子被點擊之後顯示出叉叉或圈圈，所以把 `render()` 改成下面這樣。

```jsx
render() {
  return (
  <button 
    className="square" 
    onClick={() => this.setState({value: 'X'})}
  >
    {this.state.value}
  </button>
  )
}
```
解釋

我們令 `Square` 的 button 在被點擊的時候發動一個匿名函數，這個匿名函數會啟動這個實例的 `setState()` 方法，注意到 `onClick` 是 camelCase，寫成 `onclick` 是錯的。`onClick` 的用法也是必須注意的，react 是把 function `onClick` 當成當成 props 傳進 button，讓 button 被點擊的時候啟動函數，如果傳進去的不是函數，例如下面的 code block，我們可以在 devloiper tool 裡面看到 `console.log` 在 component 被 render 的時候被呼叫 9 次。

```jsx
render() {
  return (
  <button 
    className="square" 
    onClick={console.log(123123)}
  >
    {this.state.value}
  </button>
  )
}
```

我們可以在這邊又發現一件有趣的事情，where is eventListener? 只要告訴 jsx 這個 component 的哪裡被點擊時要做什麼就好，剩下的工作它會自己完成，這就是 declarative programming 的威力。這個 feature 可以協助我們在大型專案時減少 bug。 mind blowing!

注意，我們在 react 不能直接改變 `state` 例如下面的 code block，一定要透過 `setState()` 改變，這是規定，跟 react 的 machinism 有關，在這邊我們不細講下去。

注意，我們在 `onClick` 使用 arrow function 而不是 `function`，因為 arrow function 可以避免 this 的問題。

問題: 那如果有一個 component 的狀態必須取決於其他 component 的狀態呢? 稍後解釋。

## one way data flow

React 的 state 與